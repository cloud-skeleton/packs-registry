#!/usr/bin/env python3

from warnings import filterwarnings
from urllib3.exceptions import InsecureRequestWarning
filterwarnings("ignore", category = InsecureRequestWarning)

from cryptography.x509 import (
    BasicConstraints,
    Certificate,
    CertificateBuilder,
    Name,
    NameAttribute,
    random_serial_number,
)
from cryptography.x509.oid import NameOID, ExtendedKeyUsageOID
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
from datetime import datetime, timedelta, timezone
from dxf import DXF
from nomad import Nomad
from nomad.api.exceptions import URLNotFoundNomadException
from os import getenv
from semantic_version import Version
from typing import Any, Iterable, Sequence

if not (NOMAD_SECRETS_DIR := getenv("NOMAD_SECRETS_DIR", "")):
    raise ValueError("NOMAD_SECRETS_DIR environment variable is not set.")
if not (NAMESPACE := getenv("NOMAD_NAMESPACE", "")):
    raise ValueError("NOMAD_NAMESPACE environment variable is not set.")

NOMAD_SOCKET: str = f"unix://{NOMAD_SECRETS_DIR}/api.sock"
CERTS_VAR_ROOT_PATH: str = getenv("CERTS_VAR_ROOT_PATH", "certs")
IMAGES_VARIABLE_NAME: str = getenv("IMAGES_VARIABLE_NAME", "images")
PARAMS_VAR_ROOT_PATH: str = getenv("PARAMS_VAR_ROOT_PATH", "params")
DO_NOT_ALLOW_UPDATE_MAJOR_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_MAJOR_VERSION", "true") == "true" else False
DO_NOT_ALLOW_UPDATE_MINOR_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_MINOR_VERSION", "false") == "true" else False
DO_NOT_ALLOW_UPDATE_PATCH_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_PATCH_VERSION", "false") == "true" else False
DO_NOT_ALLOW_UPDATE_PRERELEASE_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_PRERELEASE_VERSION", "true") == "true" else False
DO_NOT_ALLOW_UPDATE_BUILD_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_BUILD_VERSION", "true") == "true" else False

nomad: Nomad = Nomad(address = NOMAD_SOCKET)
def _get_var(path: str, namespace: str = NAMESPACE) -> tuple[int, dict[str, str]]:
    var: dict[str, Any] = nomad.variable.get_variable(path, namespace)
    return var["ModifyIndex"], var["Items"]

def _is_var(path: str, namespace: str = NAMESPACE) -> bool:
    try:
        _get_var(path, namespace)
        return True
    except URLNotFoundNomadException:
        return False

def _list_vars(path_prefix: str, namespace: str = NAMESPACE) -> dict[str, str]:
    return {
        var['Path']: var['Namespace']
        for var in nomad.variables.get_variables(path_prefix, namespace)
    }

def _set_var(
    path: str,
    data: dict[str, str],
    index: int | None = None,
    namespace: str = NAMESPACE
) -> tuple[int, dict[str, str]]:
    var: dict[str, Any] = nomad.variable.create_variable(path, {"Items": data}, namespace, index)
    return var["ModifyIndex"], var["Items"]

def _filter_tag(new_tag: str, current_tag: str) -> bool:
    current_tag_v: Version = Version.coerce(current_tag.removeprefix("v"))
    new_tag_v: Version
    try:
        new_tag_v = Version.coerce(new_tag.removeprefix("v"))
    except ValueError:
        return False
    if any((
        DO_NOT_ALLOW_UPDATE_BUILD_VERSION and new_tag_v.build != current_tag_v.build,
        DO_NOT_ALLOW_UPDATE_PRERELEASE_VERSION and new_tag_v.prerelease != current_tag_v.prerelease,
        DO_NOT_ALLOW_UPDATE_PATCH_VERSION and new_tag_v.patch != current_tag_v.patch,
        DO_NOT_ALLOW_UPDATE_MINOR_VERSION and new_tag_v.minor != current_tag_v.minor,
        DO_NOT_ALLOW_UPDATE_MAJOR_VERSION and new_tag_v.major != current_tag_v.major
    )):
        return False
    return new_tag_v > current_tag_v

def _get_newest_tag(current_tag: str, all_tags: list[str]) -> str:
    newer_tags: Iterable[str] = list(filter(lambda new_tag: _filter_tag(new_tag, current_tag), all_tags))
    if len(newer_tags) == 0:
        return current_tag
    return sorted(
        newer_tags,
        reverse = True,
        key = lambda tag: Version.coerce(tag.removeprefix("v"))
    )[0]

def update_images() -> None:
    latest_tags: dict[str, str] = {}
    for variable, namespace in _list_vars(f"{PARAMS_VAR_ROOT_PATH}/", "*").items():
        if not variable.endswith(f"/{IMAGES_VARIABLE_NAME}"):
            continue
        index, images = _get_var(variable, namespace)
        images_new: dict[str, str] = {}
        for image, tag in images.items():
            host: str = "registry-1.docker.io"
            repository: str = f"library/{image}"
            first, separator, rest = image.partition("/")
            if separator and '.' in first:
                host = first
                repository = rest
            print(f"Found variable {variable}@{namespace} containing {host}/{repository}:{tag} image.")
            if f"{host}/{repository}" not in latest_tags:
                dxf: DXF = DXF(
                    host,
                    repository,
                    lambda dxf, response: dxf.authenticate(
                        response = response,
                        actions = ["pull"]
                    )
                )
                latest_tags[f"{host}/{repository}"] = _get_newest_tag(tag, dxf.list_aliases())
            newest_tag: str = latest_tags[f"{host}/{repository}"]
            if tag != newest_tag:
                print(f"Updating from {host}/{repository}:{tag} to {host}/{repository}:{newest_tag}!")
            images_new[image] = newest_tag
        if images_new != images:
            print(f"Updating variable {variable}@{namespace} with value {images_new}")
            _set_var(variable, images_new, index, namespace)

def generate_ca() -> tuple[Ed25519PrivateKey, Certificate]:
    ca_key: Ed25519PrivateKey = Ed25519PrivateKey.generate()
    name: Name = Name([
        NameAttribute(NameOID.COMMON_NAME, "cloudskeleton.eu"),
        NameAttribute(NameOID.ORGANIZATION_NAME, "Cloud Skeleton"),
    ])
    now_utc: datetime = datetime.now(timezone.utc)
    ca_cert: Certificate = (
        CertificateBuilder()
            .subject_name(name)
            .issuer_name(name)
            .public_key(ca_key.public_key())
            .serial_number(random_serial_number())
            .not_valid_before(now_utc - timedelta(days = 1))
            .not_valid_after(now_utc + timedelta(days = 365))
            .add_extension(BasicConstraints(ca = True, path_length = None), critical = True)
            .sign(private_key = ca_key, algorithm = None)
    )
    return ca_key, ca_cert

def update_certificates() -> None:
    should_generate_ca: bool = not _is_var(f"{CERTS_VAR_ROOT_PATH}/ingress_to_service/ca")
    if should_generate_ca:
        ca_key, ca_cert = generate_ca()
        key_pem: str = ca_key.private_bytes(
            encoding = serialization.Encoding.PEM,
            format = serialization.PrivateFormat.PKCS8,
            encryption_algorithm = serialization.NoEncryption(),
        ).decode("utf-8")
        cert_pem: str = ca_cert.public_bytes(serialization.Encoding.PEM).decode("utf-8")
        _set_var(
            f"{CERTS_VAR_ROOT_PATH}/ingress_to_service/ca",
            {
                "certificate": cert_pem,
                "key": key_pem
            },
            0,
            NAMESPACE
        )
    if not _is_var(f"{CERTS_VAR_ROOT_PATH}/ingress_to_service/ingress"):
        print("no ingress")
    if not _is_var(f"{CERTS_VAR_ROOT_PATH}/ingress_to_service/service"):
        print("no service")

def start() -> None:
    update_certificates()
    #update_images()

if __name__ == "__main__":
    start()
