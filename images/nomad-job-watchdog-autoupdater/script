#!/usr/bin/env python3

from warnings import filterwarnings
from urllib3.exceptions import InsecureRequestWarning
filterwarnings("ignore", category = InsecureRequestWarning)

from cryptography.x509 import (
    BasicConstraints,
    Certificate,
    CertificateBuilder,
    DNSName,
    ExtendedKeyUsage,
    GeneralName,
    IPAddress,
    load_pem_x509_certificate,
    Name,
    NameAttribute,
    random_serial_number,
    SubjectAlternativeName
)
from cryptography.x509.oid import NameOID, ExtendedKeyUsageOID
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric.ec import (
    EllipticCurvePrivateKey,
    EllipticCurvePublicKey,
    generate_private_key,
    SECP521R1
)
from cryptography.hazmat.primitives.hashes import SHA512
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from datetime import datetime, timedelta, timezone
from dxf import DXF
from dxf.exceptions import DXFUnauthorizedError
from ipaddress import ip_address
from json import loads
from nomad import Nomad
from nomad.api.exceptions import URLNotFoundNomadException
from os import getenv
from semantic_version import Version
from typing import Any, Iterable

if not (NOMAD_SECRETS_DIR := getenv("NOMAD_SECRETS_DIR", "")):
    raise ValueError("NOMAD_SECRETS_DIR environment variable is not set.")
if not (NAMESPACE := getenv("NOMAD_NAMESPACE", "")):
    raise ValueError("NOMAD_NAMESPACE environment variable is not set.")

NOMAD_SOCKET: str = f"unix://{NOMAD_SECRETS_DIR}/api.sock"
CERTS_VAR_ROOT_PATH: str = getenv("CERTS_VAR_ROOT_PATH", "certs")
IMAGES_VARIABLE_NAME: str = getenv("IMAGES_VARIABLE_NAME", "images")
PARAMS_VAR_ROOT_PATH: str = getenv("PARAMS_VAR_ROOT_PATH", "params")
DO_NOT_ALLOW_UPDATE_MAJOR_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_MAJOR_VERSION", "true") == "true" else False
DO_NOT_ALLOW_UPDATE_MINOR_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_MINOR_VERSION", "false") == "true" else False
DO_NOT_ALLOW_UPDATE_PATCH_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_PATCH_VERSION", "false") == "true" else False
DO_NOT_ALLOW_UPDATE_PRERELEASE_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_PRERELEASE_VERSION", "true") == "true" else False
DO_NOT_ALLOW_UPDATE_BUILD_VERSION: bool = \
    True if getenv("DO_NOT_ALLOW_UPDATE_BUILD_VERSION", "true") == "true" else False
INGRESS_WORKER_IPS: list[str] = loads(getenv("INGRESS_WORKER_IPS", "[]"))
MAIN_WORKER_IPS: list[str] = loads(getenv("MAIN_WORKER_IPS", "[]"))

nomad: Nomad = Nomad(address = NOMAD_SOCKET)
def _get_var(path: str, namespace: str = NAMESPACE) -> tuple[int, dict[str, str]]:
    var: dict[str, Any] = nomad.variable.get_variable(path, namespace)
    return var["ModifyIndex"], var["Items"]

def _is_var(path: str, namespace: str = NAMESPACE) -> bool:
    try:
        _get_var(path, namespace)
        return True
    except URLNotFoundNomadException:
        return False

def _list_vars(path_prefix: str, namespace: str = NAMESPACE) -> dict[str, str]:
    return {
        var['Path']: var['Namespace']
        for var in nomad.variables.get_variables(path_prefix, namespace)
    }

def _set_var(
    path: str,
    data: dict[str, str],
    index: int | None = None,
    namespace: str = NAMESPACE
) -> tuple[int, dict[str, str]]:
    var: dict[str, Any] = nomad.variable.create_variable(path, {"Items": data}, namespace, index)
    return var["ModifyIndex"], var["Items"]

def _filter_tag(new_tag: str, current_tag: str) -> bool:
    current_tag_v: Version = Version.coerce(current_tag.removeprefix("v"))
    new_tag_v: Version
    try:
        new_tag_v = Version.coerce(new_tag.removeprefix("v"))
    except ValueError:
        return False
    if any((
        DO_NOT_ALLOW_UPDATE_BUILD_VERSION and new_tag_v.build != current_tag_v.build,
        DO_NOT_ALLOW_UPDATE_PRERELEASE_VERSION and new_tag_v.prerelease != current_tag_v.prerelease,
        DO_NOT_ALLOW_UPDATE_PATCH_VERSION and new_tag_v.patch != current_tag_v.patch,
        DO_NOT_ALLOW_UPDATE_MINOR_VERSION and new_tag_v.minor != current_tag_v.minor,
        DO_NOT_ALLOW_UPDATE_MAJOR_VERSION and new_tag_v.major != current_tag_v.major
    )):
        return False
    return new_tag_v > current_tag_v

def _get_newest_tag(current_tag: str, all_tags: list[str]) -> str:
    newer_tags: Iterable[str] = list(filter(lambda new_tag: _filter_tag(new_tag, current_tag), all_tags))
    if len(newer_tags) == 0:
        return current_tag
    return sorted(
        newer_tags,
        reverse = True,
        key = lambda tag: Version.coerce(tag.removeprefix("v"))
    )[0]

def update_images() -> None:
    latest_tags: dict[str, str] = {}
    for variable, namespace in _list_vars(f"{PARAMS_VAR_ROOT_PATH}/", "*").items():
        if not variable.endswith(f"/{IMAGES_VARIABLE_NAME}"):
            continue
        index, images = _get_var(variable, namespace)
        images_new: dict[str, str] = {}
        for image, tag in images.items():
            host: str = "registry-1.docker.io"
            repository: str = image if "/" in image else f"library/{image}"
            first, separator, rest = image.partition("/")
            if separator and '.' in first:
                host = first
                repository = rest
            print(f"Found variable {variable}@{namespace} containing {host}/{repository}:{tag} image.")
            if f"{host}/{repository}" not in latest_tags:
                # @TODO: add ability to pass credentials for host and host/repository from secrets variable
                dxf: DXF = DXF(
                    host,
                    repository,
                    lambda dxf, response: dxf.authenticate(
                        response = response,
                        actions = ["pull"]
                    )
                )
                try:
                    latest_tags[f"{host}/{repository}"] = _get_newest_tag(tag, dxf.list_aliases())
                    newest_tag: str = latest_tags[f"{host}/{repository}"]
                    if tag != newest_tag:
                        print(f"⚠️ Updating from {host}/{repository}:{tag} to {host}/{repository}:{newest_tag}!")
                except DXFUnauthorizedError:
                    print(f"‼️ Missing authentication to {host}/{repository} repository!")
                    newest_tag: str = tag
                images_new[image] = newest_tag
        if images_new != images:
            print(f"⚠️ Updating variable {variable}@{namespace} with value {images_new}")
            _set_var(variable, images_new, index, namespace)

def _as_pem(key: EllipticCurvePrivateKey, cert: Certificate) -> tuple[str, str]:
    key_pem: str = key.private_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PrivateFormat.PKCS8,
        encryption_algorithm = serialization.NoEncryption(),
    ).decode("utf-8")
    cert_pem: str = cert.public_bytes(serialization.Encoding.PEM).decode("utf-8")
    return key_pem, cert_pem

def generate_ca() -> tuple[EllipticCurvePrivateKey, Certificate]:
    ca_key: EllipticCurvePrivateKey = generate_private_key(SECP521R1())
    name: Name = Name([
        NameAttribute(NameOID.COMMON_NAME, "cloudskeleton.eu"),
        NameAttribute(NameOID.ORGANIZATION_NAME, "Cloud Skeleton"),
    ])
    now_utc: datetime = datetime.now(timezone.utc)
    ca_cert: Certificate = (
        CertificateBuilder()
            .subject_name(name)
            .issuer_name(name)
            .public_key(ca_key.public_key())
            .serial_number(random_serial_number())
            .not_valid_before(now_utc - timedelta(days = 1))
            .not_valid_after(now_utc + timedelta(days = 365))
            .add_extension(BasicConstraints(ca = True, path_length = None), critical = True)
            .sign(private_key = ca_key, algorithm = SHA512())
    )
    return ca_key, ca_cert

def update_ca_var() -> tuple[bool, EllipticCurvePrivateKey, Certificate]:
    var: str = f"{CERTS_VAR_ROOT_PATH}/ingress_to_main/ca"
    is_renewed: bool = not _is_var(var)
    index: int = 0
    if is_renewed:
        print("❌ No CA certificate has been found. Generating a new one!")
    else:
        index, value = _get_var(var)
        key: EllipticCurvePrivateKey = load_pem_private_key(value["private_key"].encode("utf-8"), password = None)
        cert: Certificate = load_pem_x509_certificate(value["certificate"].encode("utf-8"))
        is_renewed = (cert.not_valid_after_utc - timedelta(weeks = 4)) < datetime.now(timezone.utc)
        expiry_str: str = cert.not_valid_after_utc.strftime("%Y-%m-%d %H:%M:%S")
        if is_renewed:
            print(f"⚠️ CA certificate expiring ({expiry_str}). Generating a new one!")
        else:
            print(f"✅ CA certificate valid until {expiry_str}.")
    if is_renewed:
        key, cert = generate_ca()
        key_pem, cert_pem = _as_pem(key, cert)
        _set_var(
            var,
            {
                "certificate": cert_pem,
                "private_key": key_pem
            },
            index
        )
    return is_renewed, key, cert

def generate_leaf_cert(
    ca_key: EllipticCurvePrivateKey,
    ca_cert: Certificate,
    type: str
) -> tuple[EllipticCurvePrivateKey, Certificate]:
    key: EllipticCurvePrivateKey = generate_private_key(SECP521R1())
    name: Name = Name([
        NameAttribute(NameOID.COMMON_NAME, f"{type}.cloudskeleton.eu"),
        NameAttribute(NameOID.ORGANIZATION_NAME, "Cloud Skeleton"),
    ])
    eku: ExtendedKeyUsage = ExtendedKeyUsage([
        ExtendedKeyUsageOID.CLIENT_AUTH if type == "ingress" else ExtendedKeyUsageOID.SERVER_AUTH
    ])
    san_list: list[GeneralName] = [DNSName("cloudskeleton.eu")]
    san_list.extend(IPAddress(ip_address(ip)) for ip in (INGRESS_WORKER_IPS if type == "ingress" else MAIN_WORKER_IPS))
    now_utc: datetime = datetime.now(timezone.utc)
    cert: Certificate = (
        CertificateBuilder()
            .subject_name(name)
            .issuer_name(ca_cert.subject)
            .public_key(key.public_key())
            .serial_number(random_serial_number())
            .not_valid_before(now_utc - timedelta(days = 1))
            .not_valid_after(now_utc + timedelta(days = 90))
            .add_extension(eku, critical = False)
            .add_extension(SubjectAlternativeName(san_list), critical = False)
            .sign(private_key = ca_key, algorithm = SHA512())
    )
    return key, cert

def update_cert_var(
    is_ca_renewed: bool,
    ca_key: EllipticCurvePrivateKey,
    ca_cert: Certificate,
    type: str
) -> tuple[bool, EllipticCurvePrivateKey, Certificate]:
    var: str = f"{CERTS_VAR_ROOT_PATH}/ingress_to_main/{type}"
    is_renewed: bool = not _is_var(var)
    index: int = 0
    if is_renewed:
        print(f"❌ No {type} certificate has been found. Generating a new one!")
    else:
        index, value = _get_var(var)
        key: EllipticCurvePrivateKey = load_pem_private_key(value["private_key"].encode("utf-8"), password = None)
        cert: Certificate = load_pem_x509_certificate(value["certificate"].encode("utf-8"))
        is_renewed = (cert.not_valid_after_utc - timedelta(weeks = 4)) < datetime.now(timezone.utc)
        expiry_str: str = cert.not_valid_after_utc.strftime("%Y-%m-%d %H:%M:%S")
        if is_ca_renewed:
            is_renewed = True
            print(f"🔥 CA certificate renewed. Generating a new {type} certificate!")
        elif is_renewed:
            print(f"⚠️ {type.title()} certificate expiring ({expiry_str}). Generating a new one!")
        else:
            print(f"✅ {type.title()} certificate valid until {expiry_str}.")
    if is_renewed:
        key, cert = generate_leaf_cert(ca_key, ca_cert, type)
        key_pem, cert_pem = _as_pem(key, cert)
        _set_var(
            var,
            {
                "certificate": cert_pem,
                "private_key": key_pem
            },
            index
        )
    return is_renewed, key, cert

def update_certificates() -> None:
    is_ca_renewed, ca_key, ca_cert = update_ca_var()
    update_cert_var(is_ca_renewed, ca_key, ca_cert, "ingress")
    update_cert_var(is_ca_renewed, ca_key, ca_cert, "main")

def start() -> None:
    print("\n✨ Updating certificates...")
    update_certificates()
    print("\n✨ Updating images...")
    update_images()

if __name__ == "__main__":
    start()
